Algorithm Steps:
1. Read/restate the problem
2. Ask clarifying questions (Input, Output, Edge cases). Call out assumptions
3. Identify the type of problem it is (Ex. BFS, sliding window)
4. Why you chose one strategy over another (BFS, DFS) and tradeoffs (pros, cons)
5. Time and space complexity. Optimize?
6. High level walk through with example
7. ****CODE
8. Decompose problem as much as possible: if using helper, build out skeleton, walk through what it
would do, the inputs and outputs
9. Explain time and space complexity
10. Optimize
11. Walk through code with with common example, then edge cases - go through test cases for each helper first
Notes to self:
- read a question if you didn't understand read it again what ask interviewer waht do you think and confirm to proceed
- Brute force first to get a working solution, then optimize
- Take into account the hints, dont ignore them
- Never put helper function in the main function
- With helper, always define the base case first
- Combine same logic when possible
- Better variable and helper function names
- Identify in-order, pre-order, post- order vs dfs, bfs correctly
- Time it, determine how long it should take to get through for average person
- Even if you take care of base cases up top, still id
- Even if you take care of base cases up top, still identify base cases i helper to be able to reuse

Phone Interview:
- Number of Islands
Onsite:
- Check if the word is the same:
HashMap (Optimization) due to the number of characters in the alphabet
- Decode a String
- Encode a String
- Path + Stack Question

Google love Graph(different kinds of graphs)/Tree
- Union find, Recursion, Heap on hand from scratch

daily - 1 hour (med), 1 hour(hard) - read a question : see optimal solution and write by yourself.
Keep doing as many questions as you can. so you can raise the ability to recognize pattern matching quickly